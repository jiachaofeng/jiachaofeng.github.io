<feed xmlns="http://www.w3.org/2005/Atom"> <id>https://jiachaofeng.github.io//</id><title>CharlesJia</title><subtitle>A minimal, portfolio, sidebar, bootstrap Jekyll theme with responsive web design and focuses on text presentation.</subtitle> <updated>2021-06-29T00:20:33+08:00</updated> <author> <name>your_full_name</name> <uri>https://jiachaofeng.github.io//</uri> </author><link rel="self" type="application/atom+xml" href="https://jiachaofeng.github.io//feed.xml"/><link rel="alternate" type="text/html" hreflang="en-US" href="https://jiachaofeng.github.io//"/> <generator uri="https://jekyllrb.com/" version="4.2.0">Jekyll</generator> <rights> © 2021 your_full_name </rights> <icon>/assets/img/favicons/favicon.ico</icon> <logo>/assets/img/favicons/favicon-96x96.png</logo> <entry><title>微服务学习笔记1 - 搭建第一个Spring Boot WEB 应用</title><link href="https://jiachaofeng.github.io//posts/%E5%BE%AE%E6%9C%8D%E5%8A%A11/" rel="alternate" type="text/html" title="微服务学习笔记1 - 搭建第一个Spring Boot WEB 应用" /><published>2021-06-28T00:00:00+08:00</published> <updated>2021-06-28T00:00:00+08:00</updated> <id>https://jiachaofeng.github.io//posts/%E5%BE%AE%E6%9C%8D%E5%8A%A11/</id> <content src="https://jiachaofeng.github.io//posts/%E5%BE%AE%E6%9C%8D%E5%8A%A11/" /> <author> <name>CharlesJia</name> </author> <category term="微服务" /> <summary> ​ Spring Boot 是Spring 提供的一种框架，使开发者可以更加轻松创建一个基于Spring的应用程序。与SpringMVC的不同，SpringBoot更专注于开发微服务的后台接口，并且Spring Boot遵循 ，这使得开发者在敲业务代码的时候尽可能避免配置同维护大量的xml文件。 ​ Spring Cloud 同Spring Boot 不同，虽然大部分功能插件都是通过Spring Boot来实现（Spring Cloud就是一个个Spring Boot项目），但是Spring Cloud更关注于解决微服务使用时候遇到的问题（服务注册和发现，服务的集中配置，服务网关，服务熔断…），这里面会是将多个Spring Boot单体微服务项目整合在一起并统一管理。 ​ Spring Boot 作为一个独立的Spring 的应用程序，可以独立开发同部署. 第一个Spr... </summary> </entry> <entry><title>物化视图 MATERIALIZED VIEW</title><link href="https://jiachaofeng.github.io//posts/%E7%89%A9%E5%8C%96%E8%A7%86%E5%9B%BE/" rel="alternate" type="text/html" title="物化视图 MATERIALIZED VIEW" /><published>2021-05-20T00:00:00+08:00</published> <updated>2021-05-30T21:33:51+08:00</updated> <id>https://jiachaofeng.github.io//posts/%E7%89%A9%E5%8C%96%E8%A7%86%E5%9B%BE/</id> <content src="https://jiachaofeng.github.io//posts/%E7%89%A9%E5%8C%96%E8%A7%86%E5%9B%BE/" /> <author> <name>CharlesJia</name> </author> <category term="DB" /> <summary> 物化视图 物化视图是包括一个查询结果的数据库对象，它是远程数据的的本地副本，或者用来生成基于数据表求和的汇总表。 物化视图存储基于远程表的数据，也可以称为快照。对于复制，物化视图允许你在本地维护远程数据的副本,这些副本是只读的。 如果你想修改本地副本，必须用高级复制的功能。当你想从一个表或视图中抽取数据时，你可以用从物化视图中抽取。 对于数据仓库，创建的物化视图通常情况下是聚合视图，单一表聚合视图和连接视图。 实现两个数据库之间的数据同步，可以存在时间差。 刷新的方式 Fast Complete Force 刷新的方法 DBMS_REFRESH.Refresh DBMS_MVIEW.Refresh 普通视图 ​ 普通视图是虚拟表，应用的局限... </summary> </entry> <entry><title>转载-多线程框架</title><link href="https://jiachaofeng.github.io//posts/%E5%A4%9A%E7%BA%BF%E7%A8%8B%E6%A1%86%E6%9E%B6/" rel="alternate" type="text/html" title="转载-多线程框架" /><published>2021-05-20T00:00:00+08:00</published> <updated>2021-05-20T23:45:43+08:00</updated> <id>https://jiachaofeng.github.io//posts/%E5%A4%9A%E7%BA%BF%E7%A8%8B%E6%A1%86%E6%9E%B6/</id> <content src="https://jiachaofeng.github.io//posts/%E5%A4%9A%E7%BA%BF%E7%A8%8B%E6%A1%86%E6%9E%B6/" /> <author> <name>CharlesJia</name> </author> <category term="Java" /> <summary> 一.Java中的ThreadPoolExecutor类 java.uitl.concurrent.ThreadPoolExecutor类 在ThreadPoolExecutor类中提供了四个构造方法： public class ThreadPoolExecutor extends AbstractExecutorService { ..... public ThreadPoolExecutor(int corePoolSize,int maximumPoolSize,long keepAliveTime,TimeUnit unit, BlockingQueue&amp;lt;Runnable&amp;gt; workQueue); public ThreadPoolExecutor(int corePoolSize,int maximumPo... </summary> </entry> <entry><title>volidate关键字</title><link href="https://jiachaofeng.github.io//posts/volidate%E5%85%B3%E9%94%AE%E5%AD%97/" rel="alternate" type="text/html" title="volidate关键字" /><published>2021-05-20T00:00:00+08:00</published> <updated>2021-05-20T00:00:00+08:00</updated> <id>https://jiachaofeng.github.io//posts/volidate%E5%85%B3%E9%94%AE%E5%AD%97/</id> <content src="https://jiachaofeng.github.io//posts/volidate%E5%85%B3%E9%94%AE%E5%AD%97/" /> <author> <name>CharlesJia</name> </author> <category term="Java" /> <summary> 1.volatile关键字的两层语义 一旦一个共享变量（类的成员变量、类的静态成员变量）被volatile修饰之后，那么就具备了两层语义： 　　1）保证了不同线程对这个变量进行操作时的可见性，即一个线程修改了某个变量的值，这新值对其他线程来说是立即可见的。 　　2）禁止进行指令重排序。 　　先看一段代码，假如线程1先执行，线程2后执行： //线程1 boolean stop = false; while(!stop){ doSomething(); } //线程2 stop = true; 　这段代码是很典型的一段代码，很多人在中断线程时可能都会采用这种标记办法。但是事实上，这段代码会完全运行正确么？即一定会将线程中断么？不一定，也许在大多数时候，这个代码能够把线程中断，但是也有可能会导致无法中断线程（虽然这个可能性很小，但是只要一旦发生这种情况就会造成死循... </summary> </entry> <entry><title>转载-ConcurrentHashMap</title><link href="https://jiachaofeng.github.io//posts/ConcurrentHashMap/" rel="alternate" type="text/html" title="转载-ConcurrentHashMap" /><published>2021-05-19T00:00:00+08:00</published> <updated>2021-05-20T23:45:43+08:00</updated> <id>https://jiachaofeng.github.io//posts/ConcurrentHashMap/</id> <content src="https://jiachaofeng.github.io//posts/ConcurrentHashMap/" /> <author> <name>CharlesJia</name> </author> <category term="Java" /> <summary> ConcurrentHashMap 一、简单回顾ConcurrentHashMap在jdk1.7中的设计 先简单看下ConcurrentHashMap类在jdk1.7中的设计，其基本结构如图所示： 每一个segment都是一个HashEntry&amp;lt;K,V&amp;gt;[] table， table中的每一个元素本质上都是一个HashEntry的单向队列。比如table[3]为首节点，table[3]-&amp;gt;next为节点1，之后为节点2，依次类推。 public class ConcurrentHashMap&amp;lt;K, V&amp;gt; extends AbstractMap&amp;lt;K, V&amp;gt; implements ConcurrentMap&amp;lt;K, V&amp;gt;, Serializable { // 将整个hashmap分成几个小的map，... </summary> </entry> </feed>
